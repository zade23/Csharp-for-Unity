# Unity Tutorial - 线性差值

## 概念预习

`Lerp` 函数是 Linearly interpolates 的简称

### 线性差值法

线性插值是一种数学方法，用于在两个已知数值之间估算一个未知数值。它假设这两个已知数值之间的变化是线性的，即变化率是恒定的。在实际应用中，线性插值经常用于填补数据中的空白点，或者在两个已知数据点之间预测一个值。

例如，如果我们有两个点  \((x_1, y_1)\) 和 \((x_2, y_2)\)，并且我们需要找到 \(x\) 轴上某个点 \(x\) 对应的 \(y\) 值，那么线性插值公式可以表示为：

$$
y = y_1 + \frac{(y_2 - y_1)}{(x_2 - x_1)} \cdot (x - x_1)
$$

这里，\(y\) 是我们想要预测的值，\((x - x_1)\) 是已知点 \(x_1\) 到预测点 \(x\) 的距离，而 
$$
\frac{(y_2 - y_1)}{(x_2 - x_1)}
$$

是这两点之间的斜率。通过这个公式，我们可以计算出在 \(x\) 处的 \(y\) 值。

在制作游戏时，有时可以在两个值之间进行线性插值。这是通过 `Lerp` 函数来完成的。线性插值会在两个给定值之间找到某个百分比的值。

### 示例一 - 浮点差值

例如，我们可以在数字 3 和 5 之间按 50% 进行线性插值以得到数字 4。

这是因为 4 是 3 和 5 之间距离的 50%。

在 Unity 中，有多个 `Lerp` 函数可用于不同类型。对于我们刚才使用的示例，与之等效的将是 `Mathf.Lerp` 函数，如下所示：

```c#
// 在此示例中，result = 4
float result = Mathf.Lerp (3f, 5f, 0.5f);
```

`Mathf.Lerp` 函数接受 3个 float 参数：**<u>一个 float 参数表示要进行插值的起始值，另一个 float 参数表示要进行插值的结束值，最后一个 float 参数表示要进行插值的距离。</u>**

在此示例中，插值为 0.5，表示 50%。如果为 0，则函数将返回 “from” 值；如果为 1，则函数将返回 “to” 值。

`Lerp` 函数的其他示例包括 `Color.Lerp` 和 `Vector3.Lerp`。这些函数的工作方式与 `Mathf.Lerp` 完全相同，但是“from”和“to”值分别为 `Color` 和 `Vector3` 类型。

在每个示例中，第三个参数仍然是一个 float 参数，表示要插值的大小。

这些函数的结果是找到一种颜色（两种给定颜色的某种混合）以及一个矢量（占两个给定矢量之间的百分比）。

### 示例二 - 颜色差值

让我们看看另一个示例：

```c#
Vector3 from = new Vector3 (1f, 2f, 3f);
Vector3 to = new Vector3 (5f, 6f, 7f);

// 此处 result = (4, 5, 6)
Vector3 result = Vector3.Lerp (from, to, 0.75f);
```

在此示例中，结果为 (4, 5, 6)，因为 4 位于 1 到 5 之间的 75% 处，5 位于 2 到 6 之间的 75% 处，而 6 位于 3 到 7 之间的 75% 处。

使用 `Color.Lerp` 时适用同样的原理。在 Color 结构中，颜色由代表红色、蓝色、绿色和 Alpha 的 4 个 float 参数表示。使用 `Lerp` 时，与 `Mathf.Lerp` 和 `Vector3.Lerp` 一样，这些 float 数值将进行插值。

### 示例三 - 时间平滑

在某些情况下，可使用 `Lerp` 函数使值随时间平滑。请考虑以下代码段：

```c#
void Update ()
{
    light.intensity = Mathf.Lerp(light.intensity, 8f, 0.5f);
}
```

如果光的强度从 0 开始，则在第一次更新后，其值将设置为 4。下一帧会将其设置为 6，然后设置为 7，再然后设置为 7.5，依此类推。因此，经过几帧后，光强度将趋向于 8，但随着接近目标，其变化速率将减慢。请注意，这是在若干个帧的过程中发生的。

如果我们不希望与帧率有关，则可以使用以下代码：

```c#
void Update ()
{
    light.intensity = Mathf.Lerp(light.intensity, 8f, 0.5f * Time.deltaTime);
}
```

这意味着强度变化将按每秒而不是每帧发生。

请注意，在对值进行平滑时，通常情况下最好使用 `SmoothDamp` 函数。

仅当您确定想要的效果时，才应使用 `Lerp` 进行平滑。
